# -*- coding: utf-8 -*-
"""Linear_Regression_housing_dataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_LatBzzBNCHEsoPSNYzPGnNK-KITbqe
"""

# In this Linear Regression Analysis, I will attempt to model a line of best fit for given
# housing market data, the model will attempt to find a relation for best between 'house price of unit area' 
# as our target variable and number of convenience stores as our independent variable

#!pip3 install torch  # use if using google colab

import torch
from torch.nn import Linear
import torch.nn as nn
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

# read the dataset using pandas
# https://www.kaggle.com/quantbruce/real-estate-price-prediction
data = pd.read_csv('/content/sample_data/real_estate.csv')

# This displays the top 5 rows of the data
#data.head()

X_update = torch.tensor(data['X4 number of convenience stores'],dtype=float)
X = torch.reshape(X_update, (X_update.shape[0], -1))
Y_update = torch.tensor(data['Y house price of unit area'])
Y = torch.reshape(Y_update, (Y_update.shape[0], -1))
Y = Y.float()
X = X.float()
print(X.size())
print(Y.size())

plt.plot( X, Y, 'o')
plt.ylabel('Y')
plt.xlabel('X')
sns.pairplot(data)

class LinearRegression(nn.Module):
  def __init__(self, input_size, output_size ):
    super().__init__()
    self.linear = nn.Linear(input_size, output_size)

  def forward(self, x):
    Y_prod = self.linear(x)
    return Y_prod

# Create a Model Instance of the Linear Regression Class
model = LinearRegression(1,1)

[w, b] = model.parameters() # Parameters are returned in a 2D Tensor with 1 Row and 1 Column
def get_params():
  return (w[0][0].item(), b[0].item())

def plot_fit(title):
  plt.title = title
  w1, b1 = get_params() # get the weight and bias values from the model
  x1 = np.array([-1,10])
  print(x1) # array of 2 elements -1 and 10
  y1 = w1 * x1 + b1
  plt.plot(x1, y1, 'r')
  plt.scatter(X, Y)
  plt.show()

plot_fit('Initial Model')

criterion = nn.MSELoss()

#will use SGD to update the weights and bias
optimizer = torch.optim.SGD(model.parameters(), lr = 0.01)

# 1 epoch is a single pass through the entire Dataset, we calculate the error function and backpropogate 
# the gradient of the error function to update the weights
epochs = 1000
losses = []


# we want to minimize the error in each epoch pass
for i in range(epochs):
  y_pred = model.forward(X) # 1. Make predictions using our Model
  loss = criterion(y_pred, Y) # 2. Compare the predictions made by the model to the actual outputs, to determine MSE, Mean squared error
  print("epoch: ", i, "loss: ", loss.item())
  losses.append(loss)
  optimizer.zero_grad() # set the gradient to zero, since gradients accumulate following loss.backward() call from previous epoch
  loss.backward()     # take the gradient of the loss function, we use loss.backward() to computer gradient
  optimizer.step()    # we update our model parameters by optimizer.step(), can be called once gradients are computed

plt.plot(range(epochs), losses)
plt.ylabel('Loss')
plt.xlabel('Epoch')

plot_fit('Trained Model')

#final weights and bias
final_weight, final_bias = get_params()
print(final_weight)
print(final_bias)
